<!DOCTYPE html>
<html>
<head>
  <title>Error Handling</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body { font-family: 'Droid Serif'; color: #333333; }
    h1 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; color: #074548; }
    h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; color: #6f9a9c; }
    .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    .medium { font-size: 28px; }
    .large { font-size: 36px; }
    .medium-left { float: left; width: 37%; }
    .half-left { float: left; width: 47%; }
    .large-left { float: left; width: 57%; }
    .small-right { float: right; width: 27%; }
    .medium-right { float: right; width: 37%; }
    .half-right { float: right; width: 47%; }
    .large-right { float: right; width: 57%; }
    .footer { position: absolute; bottom: 12px; left: 45px }
    table { border-collapse: collapse; display: inline-block; }
    th, td { padding: 10px; border: 1px solid black; }
    tr:nth-child(even) {background-color: #f2f2f2;}
    .hl { color : blue }
  </style>
</head>
<body>
<textarea id="source">

class: center, middle

<a href="https://github.com/fp-tower/foundation">
  <img src="img/solid-color-logo.svg" alt="logo" style="width:600px;"/>
</a>

<br>
<br>


# Error Handling

---
layout: true

<div class="footer">
  <a href="https://github.com/fp-tower/foundation">
    <img src="img/symbol-solid-gray-b3b3b3.svg" alt="logo" style="width:100px;"/>
  </a>
</div>

---
class: center, middle

# How to deal with runtime errors


---
background-image: url(img/errorhandling/partial-function-1.svg)

# Partial Function

---
background-image: url(img/errorhandling/partial-function-2.svg)

# Partial Function

---
.h1[# Error handling objectives]

.large[
<br>
1. Document when and what type of errors can occur

1. Force caller to deal with errors

1. Make it easy to fail
]

---
# Exception

```scala
case class Item(id: Long, unitPrice: Double, quantity: Int)

case class Order(status: String, basket: List[Item])

def submit(order: Order): Order =
  order.status match {
    case "Draft" if order.basket.nonEmpty =>
      order.copy(status = "Submitted")
    case other =>
      throw new Exception("Invalid Command")
  }
```

```scala
scala> submit(Order("Draft", Nil))
java.lang.Exception: Invalid Command
  at .submit(<console>:7)
  ... 42 elided
```

---
# Exception

```scala
case object EmptyBasketError extends Exception
case class InvalidCommandError(command: String, order: Order) extends Exception

def submit(order: Order): Order =
  order.status match {
    case "Draft" =>
      if(order.basket.isEmpty) throw EmptyBasketError
      else order.copy(status = "Submitted")
    case other =>
      throw new InvalidCommandError("submit", order)
  }
```

```scala
scala> submit(Order("Draft", Nil))
EmptyBasketError$
  ... 44 elided

scala> submit(Order("Delivered", Nil))
InvalidCommandError
  at .submit(<console>:8)
  ... 42 elided
```

---
# Exceptions are not documented

```scala
def submit(order: Order): Order = ???

def canSubmit(order: Order): Boolean =
  try {
    submit(order)
    true
  } catch {
    case EmptyBasketError       => false
    case _: InvalidCommandError => false
    case _: ArithmeticException => true
    case _: Exception           => false
  }
```

--

### In Java, you have checked Exception

```java
public Order submit(Order order) `throws EmptyBasketError, InvalidCommandError`
```

---
.h1[# Pure Function is a mapping between types]

.large-left[![Partial Function](img/errorhandling/pure-function-1.svg)]

.medium-right[
.medium[
<br>
* Powerful refactoring
* Local reasoning
* Easier to test
* Potential performance optimisation
* Better documentation
]
]

---
.h1[# Functions with side effects are not pure]

.half-left[![Partial Function](img/errorhandling/side-effect.svg)]

.half-right[
```scala
def getDebitCard(userId: UserId): DebitCard = {
  val user = db.getUser(userId)
  user.debitCard
}


def deleteDebitCard(userId: UserId): DebitCard = {
  val user = db.getUser(userId)
  val debitCard = user.debitCard
  db.upsertDebitCard(userId, null)
  debitCard
}
```
]

---
.h1[# Pure side effects and exceptions with IO]

.half-left[
![IO](img/errorhandling/io.svg)
]

.half-right[
<br>
```scala
def extractDebitCard(user: User): IO[DebitCard] = {
  if(user.debitCard == null)
    IO.fail(new Exception("No debit card"))
  else
    IO.succeed(user.debitCard)
}


def deleteDebitCard(db: DbApi, userId: UserId): IO[DebitCard] =
  for {
    user      <- db.getUser(userId)
    debitCard <- extractDebitCard(user)
    _         <- db.upsertDebitCard(userId, null)
  } yield debitCard
```
]

---
# IO error handling is fragile

```scala
def deleteCard(userId: UserId): IO[DebitCard] = ???

val httpRoute = {
  case DELETE -> Root / "user" / UserId(x) / "card" =>
    deleteCard(x)
      .flatMap(Ok(_))
      .handleErrorWith {
        case _: UserMissing | _: CardMissing => NotFound()
        case _: ExpiredCard                  => BadRequest()
        case _: Throwable                    => InternalServerError()
      }
}
```

```scala
def handleErrorWith[A, B](io: IO[A])(f: `Throwable` => IO[B]): IO[B] = ???
```

---
background-image: url(img/errorhandling/io-big.svg)

# IO can be too many things

---
background-image: url(img/errorhandling/partial-function-1.svg)

# Can we use a type dedicated to error handling?

---
background-image: url(img/errorhandling/pure-error-handling.svg)

# Pure Error Handling

---
class: center, middle

# Which types can we use?

---
.h1[# Type constructors with an error channel]

<br>

.large[
* `Option`

* `Try`

* `Either`
]

---
.h1[# Plan]

<br>

.large[
* Look at use cases for `Option`, `Try` and `Either`

* Practice the design of error ADTs (Algebraic Data Type)

* How to use `Option` and `Either` in conjunction with `IO`
]


---
.h1[# Option]

.half-left[
```scala
sealed trait Option[+A]

object Option {
  case class Some[+A](value: A) extends Option[A]
  case object None extends Option[Nothing]
}
```
]

.half-right[![Option](img/errorhandling/option.svg)]


---
.h1[# Option documents which values are optional]

.half-left[
```scala
case class User(
  id     : java.util.UUID,
  name   : String,
  age    : Int,
  email  : Option[String],
  address: Option[String]
)
```
]

.half-right[
```sql
CREATE TABLE users (
  id      UUID NOT NULL,
  name    TEXT NOT NULL,
  age     INT  NOT NULL,
  email   TEXT,
  address TEXT
)
```
]

---
.h1[# Option forces us to think about empty case]

.half-left[
```scala
def longest(xs: List[String]): Option[String] = {
  var current: Option[String] = None

  for (x <- xs) {
    current match {
      case Some(max) if max.length > x.length =>
        () // do nothing
      case _ =>
        current = Some(x)
    }
  }

  current
}
```
]

.half-right[
```scala
def longest(xs: List[String]): String = {
  var current: String = null

  for (x <- xs) {

    if(current != null && current.length > x.length) {
      () // do nothing
    } else {
      current = x
    }
  }

  current
}
```
]

---
# Option is a List with at most one element

```scala
scala> Some("hello").toList
res3: List[String] = List(hello)

scala> None.toList
res4: List[Nothing] = List()

scala> List(Some(3), None, Some(4), None, None, Some(5)).flatMap(_.toList)
res5: List[Int] = List(3, 4, 5)
```

---
class: center, middle

# Option Exercise 1

`exercises.errorhandling.OptionExercises.scala`

---
# Variance

```scala
sealed trait Option[`+`A]

object Option {

  case class Some[`+`A](value: A) extends Option[A]

  case object None extends Option[Nothing]

}
```

--

```scala
trait Foo[+A] // Foo is covariant
trait Foo[-A] // Foo is contravariant
trait Foo[ A] // Foo is invariant
```

---
.h1[# Shape]

<br>
<br>
<br>

.medium-left[
![Shape Hierarchy](img/errorhandling/shape-hierarchy.svg)
]

.large-right[
```scala
sealed trait Shape

case class Circle(radius: Int) extends Shape

case class Rectangle(width: Int, height: Int) extends Shape
```
]

---
background-image: url(img/errorhandling/option-shape-hierarchy-1.svg)

# What is the relationship for Option[Shape]?

---
background-image: url(img/errorhandling/option-shape-hierarchy-2.svg)

# Option is covariant

---
background-image: url(img/errorhandling/invariant-option-shape-hierarchy.svg)

# If Option were invariant

---
.h1[# Type hierarchy]

.half-left[
![Type Hierarchy](img/errorhandling/type-hierarchy.svg)
]

.half-right[
```scala
val bool: Boolean = true
val five: Int = 5
val hello: String = "Hello"
val shape: Shape = Circle(5)

val anyVals: List[AnyVal] = List(bool, five)
val anyRefs: List[AnyRef] = List(hello, shape, null)

val anys: List[Any] = anyVals ++ anyRefs
```
]

---
background-image: url(img/errorhandling/covariance.svg)

.h1[# Covariance]

---
background-image: url(img/errorhandling/type-hierarchy-option.svg)

---
# Variance is type checked

```scala
sealed trait Option[`-`A]

object Option {
  case class Some[`-`A](value: A) extends Option[A]
  case object None extends Option[Nothing]
}


scala> contravariant type A occurs in covariant position in type => A of value value
  case class Some[-A](value: A) extends Option[A]
```

---
class: center, middle

# Option Exercises 2, 3 and 4

`exercises.errorhandling.OptionExercises.scala`

---
.h1[# Use Option when]

<br>

.large[
* A value may be missing

* An operation can fail in a unique obvious way

* An operation can fail in many ways but we don't need any information about the error
]

---
.h1[# Either]

.large-left[
```scala
sealed trait Either[+E, +A]

object Either {
  case class  Left[+E](value: E) extends Either[E, Nothing]
  case class Right[+A](value: A) extends Either[Nothing, A]
}
```
]

.medium-right[![Either](img/errorhandling/either.svg)]

---
# Either is the canonical encoding of OR




```scala
def getUser(userIdOrEmail: Either[UserId, Email]): IO[User] =
  userIdOrEmail match {
    case Left(userId) => db.getUserById(userId)
    case Right(email) => db.getUserByEmail(email)
  }
```

### Either[UserId, Email] represents a UserId OR an Email

--

### How would you encode a UserId AND an Email?

---
# Either is the canonical encoding of OR

```scala
def getUser(userIdOrEmail: Either[UserId, Email]): IO[User] =
  userIdOrEmail match {
    case Left(userId) => db.getUserById(userId)
    case Right(email) => db.getUserByEmail(email)
  }
```

### Either[UserId, Email] represents a UserId OR an Email

### (UserId, Email) represents a UserId AND an Email

---
class: center, middle

# Either[???, A]

---
# String Error

```scala
def submit(order: Order): Either[String, Order] =
  order.status match {
    case "Draft" =>
      if(order.basket.isEmpty) Left("Basket is empty")
      else Right(order.copy(status = "Submitted"))
    case _ =>
      Left(s"Cannot submit an order in ${order.status}")
  }
```

```scala
scala> submit(Order("Draft", List(Item(111, 12.25, 2))))
res6: Either[String,Order] = Right(Order(Submitted,List(Item(111,12.25,2))))

scala> submit(Order("Draft", Nil))
res7: Either[String,Order] = Left(Basket is empty)

scala> submit(Order("Delivered", Nil))
res8: Either[String,Order] = Left(Cannot submit an order in Delivered)
```

---
# Enum Error

```scala
sealed trait OrderError
case object EmptyBasketError extends OrderError
case class InvalidAction(action: String, status: String) extends OrderError

def submit(order: Order): Either[OrderError, Order] =
  order.status match {
    case "Draft" =>
      if(order.basket.isEmpty) Left(EmptyBasketError)
      else Right(order.copy(status = "Submitted"))
    case _ =>
      Left(InvalidAction("submit", order.status))
  }
```

```scala
scala> submit(Order("Draft", List(Item(111, 12.25, 2))))
res9: Either[OrderError,Order] = Right(Order(Submitted,List(Item(111,12.25,2))))

scala> submit(Order("Draft", Nil))
res10: Either[OrderError,Order] = Left(EmptyBasketError)

scala> submit(Order("Delivered", Nil))
res11: Either[OrderError,Order] = Left(InvalidAction(submit,Delivered))
```

---
# Enum Error

```scala
def canSubmit(order: Order): Boolean =
  submit(order) match {
    case Right(_)               => true
    case Left(EmptyBasket)      => false
    case Left(_: InvalidAction) => false
  }
```

---
# Enum Error

```scala
def canSubmit(order: Order): Boolean =
  submit(order) match {
    case Right(_)               => true
    case Left(_: InvalidAction) => false
  }
```

```scala
On line 3: warning: match may not be exhaustive.
It would fail on the following input: Left(EmptyBasketError)
```

---
# Throwable Error

```scala
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import scala.util.Try

val formatter = DateTimeFormatter.ofPattern("uuuu-MM-dd")

def parseLocalDate(dateStr: String): Either[Throwable, LocalDate] =
  Try(LocalDate.parse(dateStr, formatter)).toEither
```

```scala
scala> parseLocalDate("2019-09-12")
res12: Either[Throwable,java.time.LocalDate] = Right(2019-09-12)

scala> parseLocalDate("12 July 1996")
res13: Either[Throwable,java.time.LocalDate] = Left(java.time.format.DateTimeParseException: Text '12 July 1996' could not be parsed at index 0)
```

---
class: center, middle

# Why do we use Left for error and Right for success?

---
class: center, middle

# It is completely arbitrary

---
# Either is Right biased

```scala
def map[E, A, B](either: Either[E, A])(f: A => B): Either[E, B] = ???
```

```scala
scala> parseLocalDate("2019-09-12").map(_.plusDays(2))
res14: scala.util.Either[Throwable,java.time.LocalDate] = Right(2019-09-14)
```

--

<br>

```scala
def flatMap[E, A, B](either: Either[E, A])(f: A => Either[E, B]): Either[E, B] = ???
```

```scala
scala> for {
     |   date1 <- parseLocalDate("2019-01-24")
     |   date2 <- parseLocalDate("2020-09-12")
     | } yield date1.isBefore(date2)
res15: scala.util.Either[Throwable,Boolean] = Right(true)
```


---
class: center, middle

# Either Exercises

`exercises.errorhandling.EitherExercises.scala`

---
class: center, middle

# Either is an Option with polymorphic error type

---
class: center, middle

# Option is a special case of Either

---
class: center, middle

# type Option[+A] = Either[Unit, A]

---
class: center, middle

# type Try[+A] = Either[Throwable, A]

---
background-image: url(img/errorhandling/error-conversion.svg)

---
.h1[# Either Summary]

<br>

.large[
* Use when you need to capture details about failure

* ADTs are generally the best way to encode errors

* Two modes:
  * Fail early with `flatMap`
  * Accumulate failures with `parMap`, `parSequence`
]

---
background-image: url(img/errorhandling/error-decision-tree.svg)

---
background-image: url(img/errorhandling/error-decision-tree-2.svg)

---
# Option with IO




```scala
trait OrderApi {
  def getUser(userId: UserId): IO[Option[User]]
  def getOrder(orderId: OrderId): IO[Option[Order]]
}

def getOrderDetails(api: OrderApi)(userId: UserId, orderId: OrderId): IO[OrderDetails] =
  for {
    optUser  <- api.getUser(userId)
    optOrder <- api.getOrder(orderId)
  } yield ???
```

---
# Option with IO

```scala
trait OrderApi {
  def getUser(userId: UserId): IO[Option[User]]
  def getOrder(orderId: OrderId): IO[Option[Order]]
}

def getOrderDetails(api: OrderApi)(userId: UserId, orderId: OrderId): IO[OrderDetails] =
  for {
    optUser  <- api.getUser(userId)
    optOrder <- api.getOrder(orderId)
    user     <- optUser match {
      case None    => IO.fail(new Exception(s"User not found $userId"))
      case Some(x) => IO.succeed(x)
    }
    order    <- optOrder match {
      case None    => IO.fail(new Exception(s"Order not found $orderId"))
      case Some(x) => IO.succeed(x)
    }
  } yield ???
```

---
# Option with IO

```scala
trait OrderApi {
  def getUser(userId: UserId): IO[Option[User]]
  def getOrder(orderId: OrderId): IO[Option[Order]]
}

def fromOption[A](opt: Option[A])(error: => Throwable): IO[A] =
  opt match {
    case None    => IO.fail(error)
    case Some(x) => IO.succeed(x)
  }

def getOrderDetails(api: OrderApi)(userId: UserId, orderId: OrderId): IO[OrderDetails] =
  for {
    user  <- api.getUser(userId).flatMap(fromOption(_)(new Exception(s"User not found $userId")))
    order <- api.getOrder(orderId).flatMap(fromOption(_)(new Exception(s"Order not found $orderId")))
  } yield ???
```

---
# Option with IO

```scala
sealed trait ApplicationError extends Exception
case class UserNotFound(userId: UserId) extends ApplicationError
case class OrderNotFound(orderId: OrderId) extends ApplicationError

trait OrderApi {
  def getUser(userId: UserId): IO[Option[User]]
  def getOrder(orderId: OrderId): IO[Option[Order]]
}

def getOrderDetails(api: OrderApi)(userId: UserId, orderId: OrderId): IO[OrderDetails] =
  for {
    user  <- api.getUser(userId).flatMap(fromOption(_)(UserNotFound(userId)))
    order <- api.getOrder(orderId).flatMap(fromOption(_)(OrderNotFound(orderId)))
  } yield ???
```

---
# Option with IO

```scala
sealed trait ApplicationError extends Exception
case class UserNotFound(userId: UserId) extends ApplicationError
case class OrderNotFound(orderId: OrderId) extends ApplicationError

trait OrderApi {
  def getUserOpt(userId: UserId): IO[Option[User]]
  def getOrderOpt(orderId: OrderId): IO[Option[Order]]

  def getUser(userId: UserId): IO[User]     = getUserOpt(userId).flatMap(fromOption(_)(UserNotFound(userId)))
  def getOrder(orderId: OrderId): IO[Order] = getOrderOpt(orderId).flatMap(fromOption(_)(OrderNotFound(orderId)))
}

def getOrderDetails(api: OrderApi)(userId: UserId, orderId: OrderId): IO[OrderDetails] =
  for {
    user  <- api.getUser(userId)
    order <- api.getOrder(orderId)
  } yield ???
```

---
# OptionT

```scala
case class OptionT[+A](value: IO[Option[A]]) {
  def map[B](f: A => B): OptionT[B] =
    OptionT(value.map(_.map(f)))

  def flatMap[B](f: A => OptionT[B]): OptionT[B] =
    OptionT(value.flatMap {
      case None    => IO.succeed(None)
      case Some(a) => f(a).value
    })
}
```

--

```scala
trait DbApi {
  def getUser(userId: UserId): OptionT[User]
  def getOrder(orderId: OrderId): OptionT[Order]
}

def getOrderDetails(db: DbApi)(userId: UserId, orderId: OrderId): OptionT[OrderDetails] =
  for {
    user  <- db.getUser(userId)
    order <- db.getOrder(orderId)
  } yield ???
```

---
# More general pattern

```scala
case class OptionT[F[+_], +A](value: F[Option[A]])

type IOOptionT[A]   = OptionT[IO, A]
type ListOptionT[A] = OptionT[List, A]
```

```scala
case class EitherT[F[+_], +E, +A](value: F[Either[E, A]])

type IOEitherT[E, A]   = EitherT[IO, E, A]
type ListEitherT[E, A] = EitherT[List, E, A]
```

---
.h1[# Conclusion]

<br>

.large[
* Option and Either are the two main types to encode failures

* Try is a helpful tool to catch Exception

* Error ADTs can be as granular as we want

* Option and Either can be used in conjunction with IO
]

---
# Resources and further study

* [Scala Best Practices I Wish Someone'd Told Me About](https://nrinaudo.github.io/talk-scala-best-practices/#1)

---
class: center, middle

# [Module 4: Type](4-Type.html#1)

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
    var slideshow = remark.create({
        ratio: "16:9",
        slideNumberFormat: '%current%',
        // highlightStyle: "github",
        highlightLines: true,
        highlightSpans: true,
    });
</script>
</body>
</html>
